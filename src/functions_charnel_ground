// #include "../include/minishell.h"


t_ecode	open_redirs(t_shell *shell, t_cmd *cmd)
{
	if (!shell || !cmd)
		return (NULL_ERROR);
	while (cmd->redir)
	{
		if (cmd->redir->redir_id == HERE)
			cmd->redir->fd = ft_atoi(cmd->redir->file);
		else if (cmd->redir->redir_id == IN)
			cmd->redir->fd = open(cmd->redir->file, O_RDONLY);
		else if (cmd->redir->redir_id == OUT)
			cmd->redir->fd = open(cmd->redir->file, O_WRONLY | O_TRUNC | O_CREAT, 0644);
		else if (cmd->redir->redir_id == APP)
			cmd->redir->fd = open(cmd->redir->file, O_WRONLY | O_APPEND | O_CREAT, 0644);
		else
			//Run Alex's close all fd's and exit.
		if (cmd->redir->redir_id == HERE || cmd->redir->redir_id == IN)
		{
			if (cmd->latest_in != REDIR_INIT)
				close(cmd->latest_in); //Protect
			cmd->latest_in = cmd->redir->fd;
		}
		else if (cmd->redir->redir_id == OUT || cmd->redir->redir_id == APP)
		{
			if (cmd->latest_out != REDIR_INIT)
				close(cmd->latest_out); //Protect
			cmd->latest_out = cmd->redir->fd;
		}
		if (cmd->redir->fd == -1)
			//Perror, Alex and good bye.
		cmd->redir = cmd->redir->next;
	}
	return (SUCCESS);
}

// void	execute_single_command(t_shell *shell, t_cmd *cmd)
// {
// 	shell->parent = fork();
// 	if (shell->parent == -1)
// 		return ;
// 	else if (shell->parent == 0)
// 		run_child_single_command(shell, cmd);
// 	waitpid(shell->parent, &shell->status, 0);
// 	// printf("Finished waiting for children. Status: %d\n", shell->status);
// }

// static void	run_child_single_command(t_shell *shell, t_cmd *cmd)
// {
// 	char	*cmd_path;
// 	char	**env_array;

// 	// handle_redirections(shell, cmd);
// 	cmd_path = get_cmd_path(shell, shell->cmd_list->args[0]);
// 	env_array = create_env_array(shell->env_list);
// 	execve(cmd_path, cmd->args, env_array);
// }

// void	handle_redirections(t_shell *shell, t_cmd *cmd)
// {
// 	int	input_fd;

// 	close(shell->pipefd[READ_END]);
// 	input_fd = handle_input(shell, cmd);
// 	dup2(input_fd, STDIN_FILENO);
// 	close(input_fd);
// 	dup2(shell->pipefd[WRITE_END], STDOUT_FILENO);
// 	close(shell->pipefd[WRITE_END]);
// }

// int	handle_input(t_shell *shell, t_cmd *cmd)
// {
// 	t_redir	*iterator;
// 	char	*infile_name;
// 	int		infile_fd;

// 	(void) shell;
// 	if (!cmd || cmd->redir)
// 		return (0);
// 	iterator = cmd->redir;
// 	while (iterator->redir)
// 	{
// 		if (iterator->redir == IN || iterator->redir == HERE) //Change HERE to HDOC
// 			infile_name = iterator->file;
// 		iterator = iterator->next;
// 	}
// 	infile_fd = open(infile_name, O_CREAT);
// 	return (infile_fd);
// }

//	OLD ENV_INIT FUNCTION
t_ecode	init_env_list(t_env **head, char **envp)
{
	t_env		*current;
	t_env		*new_node;
	t_ecode		status;	
	size_t		i;

	if (!envp || !*envp)
		return (NULL_ERROR);
	i = 0;
	while (envp[i])
	{
		new_node = new_copied_env_node(envp[i], &status);
		if (status != SUCCESS)
			return (status);
		if (!*head)
		{
			*head = new_node;
			current = *head;
		}
		else
		{
			current->next = new_node;
			current = current->next;
		}
		i++;
	}
	return (SUCCESS);
}

static t_env	*new_copied_env_node(char *keyvalue, t_ecode *status)
{
	t_env	*new_node;

	*status = SUCCESS;
	new_node = new_env_node();
	if (!new_node)
	{
		*status = NEW_NODE_ERROR;
		return (NULL);
	}
	*status = copy_keyvalue_into_env_node(&new_node, keyvalue);
	if (*status != SUCCESS)
		return (NULL);
	return (new_node);
}

t_env	*new_populated_env_node(char *key, char *value)
{
	t_env	*new_node;
	
	new_node = new_env_node();
	if (!new_node)
		return (NULL);
	if (update_key_in_env_node(new_node, key))
	{
		ft_free((void **) &new_node);
		return (NULL);
	}
	if (update_value_in_env_node(new_node, value))
	{
		ft_free((void **) &new_node->key);
		ft_free((void **) &new_node->keyvalue);
		ft_free((void **) &new_node);
		return (NULL);
	}
	return (new_node);
}

// char	*get_value_from_keyvalue(char *keyvalue) // Old version
// {
// 	char	*value;
// 	int		i;
// 	int		value_len;
	

// 	if (!keyvalue || !keyvalue[0])
// 		return (NULL);
// 	i = 0;
// 	while (*keyvalue && *keyvalue != '=')
// 		keyvalue++;
// 	keyvalue++;
// 	value_len = ft_strlen(keyvalue);
// 	value = ft_calloc(value_len + 1, sizeof(char));
// 	if (!value)
// 		return (NULL);
// 	i = 0;
// 	while (i < value_len)
// 	{
// 		value[i] = keyvalue[i];
// 		i++;
// 	}
// 	value[i] = '\0';
// 	return (value);
// }

// t_ecode	update_oldpwd(t_env	*oldpwd_node, char *cwd)
// {
// 	if (!oldpwd_node)
// 	{
// 		oldpwd_node = new_populated_env_node("PWD", getcwd(NULL, PATH_MAX));
// 		if (!pwd_node)
// 			return (MALLOC_ERROR);
// 	}
// 	else
// 	{
// 		if (update_value_in_env_node(pwd_node, getcwd(NULL, PATH_MAX)))
// 			return (MALLOC_ERROR);
// 	}
// 	return (SUCCESS);
// }

// t_ecode update_key_in_env_node(t_env *node, char *key)
// {
// 	if (!node || !key)
// 		return (NULL_ERROR);
// 	if (node->key)
// 		ft_free((void **) &node->key);
// 	else
// 	{
// 		node->key = ft_strdup(key);
// 		if (!node->key)
// 			return (MALLOC_ERROR);
// 	}
// 	if (update_keyvalue_in_env_node(node))
// 		return (MALLOC_ERROR);
// 	return (SUCCESS);
// }


t_ecode	copy_keyvalue_into_env_node(t_env **new_node, char *keyvalue)
{
	t_ecode	status;

	(*new_node)->keyvalue = ft_strdup(keyvalue);
	if (!(*new_node)->keyvalue)
		return (MALLOC_ERROR);
	(*new_node)->key = get_key_from_keyvalue((*new_node)->keyvalue);
	if (!(*new_node)->key)
		return (MALLOC_ERROR);
	status = get_value_from_keyvalue((*new_node)->keyvalue, &(*new_node)->value);
	if (!(*new_node)->value)
		return (MALLOC_ERROR);
	(*new_node)->next = NULL;
	return (SUCCESS);
}

//FROM INIT_SHELL.c
// int	unset_env_var(char *key, t_env **env_list)  //builtin
// {
// 	int		key_len;
// 	t_env	*current;
// 	t_env	*temp_var;

// 	if (!key)
// 		return (-2); //malloc error
// 	current = *env_list;
// 	temp_var = NULL;
// 	key_len = ft_strlen(key);
// 	while (current != NULL && current->next != NULL)
// 	{
// 		if (ft_strncmp(current->next->key, key, key_len) == 0)
// 		{
// 			temp_var = current->next;
// 			current->next = temp_var->next;
// 			free_env_node(temp_var);
// 			return (0); //SUCCESS
// 		}
// 		current = current->next;
// 	}
// 	return (0); // variable name not found thus not unset! // SUCCESS
// }

// int	init_shell_update_SHLVL(t_env **env_list)
// {
// 	t_env	*shlvl_node;
// 	unsigned int	value;

// 	shlvl_node = get_env_node("SHLVL", *env_list);
// 	if (shlvl_node)
// 	{
// 		value = ft_atoi(shlvl_node->value) + 1;
// 		if (shlvl_node->value)
// 			free(shlvl_node->value);
// 		shlvl_node->value = ft_itoa(value);
// 		if (!shlvl_node->value)
// 			return (1);
// 		return (0);
// 	}
// 	shlvl_node = new_env_var("SHLVL=1");
// 	if (!shlvl_node)
// 		return (1);
// 	add_env_var_in_back(env_list, shlvl_node);
// 	return (0);
// }

// int	init_shell(char **envp, t_shell *shell)
// {
// 	t_env	*env_list;
// 	t_env	*env_var;
// 	int		i;

// 	env_list = NULL;
// 	i = 0;
// 	while (envp[i] != NULL)
// 	{
// 		env_var = new_env_var(envp[i]);
// 		if (!env_var)
// 			return (free_env_list(env_list), 1);
// 		add_env_var_in_back(&env_list, env_var);
// 		i++;
// 	}
// 	if (init_shell_update_SHLVL(&env_list))
// 		return (free_env_list(env_list), 1);
// 	unset_env_var("OLDPWD", &env_list);
// 	shell->env_list = env_list;
// 	return (0);
// }


//--------------------------


// char	*get_value_from_keyvalue(char *keyvalue)
// {
// 	char	*value;
// 	int		i;
// 	int		j;
// 	int		value_len;
	
// 	if (!keyvalue || !keyvalue[0])
// 		return (NULL);
// 	while (*keyvalue && *keyvalue != '=')
// 		keyvalue[i++];
// 	value_len = ft_strlen(keyvalue);
// 	value = ft_calloc(value_len, sizeof(char));
// 	if (!value)
// 		return (NULL);
// 	j = 0;
// 	keyvalue[i++];
// 	while (j < i)
// 	{
// 		value[j] = keyvalue[i + j];
// 		j++;
// 	}
// 	value[j] = '\0';
// 	return (value);
// }

// char	*get_key_from_keyvalue(char *keyvalue)
// {
// 	char	*key;
// 	int		i;
// 	int		j;

// 	if (!keyvalue || !keyvalue[0])
// 		return (NULL);
// 	i = 0;
// 	while (keyvalue[i] && keyvalue[i] != '=')
// 		i++;
// 	key = ft_calloc(i + 1, sizeof(char));
// 	if (!key)
// 		return (NULL);
// 	j = 0;
// 	while (j < i)
// 	{
// 		key[j] = keyvalue[j];
// 		j++;
// 	}
// 	key[j] = '\0';
// 	return (key);
// }


// t_ecode	copy_keyvalue_into_env_node(t_env **new_node, char *keyvalue)
// {
// 	(*new_node)->keyvalue = ft_strdup(keyvalue);
// 	if (!(*new_node)->keyvalue)
// 		return (MALLOC_ERROR);
// 	(*new_node)->key = get_key_from_keyvalue((*new_node)->keyvalue);
// 	if (!(*new_node)->key)
// 		return (MALLOC_ERROR);
// 	(*new_node)->value = get_value_from_keyvalue((*new_node)->keyvalue);
// 	if (!(*new_node)->value)
// 		return (MALLOC_ERROR);
// 	(*new_node)->next = NULL;
// 	return (SUCCESS);
// }

// t_env	*new_env_node(void)
// {
// 	t_env	*new_node;
	
// 	new_node = ft_calloc(1, sizeof(t_env));
// 	if (!new_node)
// 		return (NULL);
// 	new_node->keyvalue = NULL;
// 	new_node->key = NULL;
// 	new_node->value = NULL;
// 	return (new_node);
// }

// ssize_t	count_envp_keys(char **envp)
// {
// 	int	i;

// 	if (!envp || !*envp)
// 		return (-1);
// 	i = 0;
// 	while (envp[i])
// 		i++;
// 	return (i);
// }

// static t_env	*new_copied_env_node(char *keyvalue, t_ecode *status)
// {
// 	t_env	*new_node;

// 	*status = SUCCESS;
// 	new_node = new_env_node();
// 	if (!new_node)
// 	{
// 		*status = NEW_NODE_ERROR;
// 		return (NULL);
// 	}
// 	*status = copy_keyvalue_into_env_node(&new_node, keyvalue);
// 	if (*status != SUCCESS)
// 		return (NULL);
// 	return (new_node);
// }

// t_ecode	init_env_list(t_env **head, char **envp)
// {
// 	t_env		*current;
// 	t_env		*new_node;
// 	t_ecode	status;	
// 	size_t		i;

// 	if (!envp || !*envp)
// 		return (NULL_ERROR);
// 	i = 0;
// 	while (envp[i])
// 	{
// 		new_node = new_copied_env_node(envp[i], &status);
// 		if (status != SUCCESS)
// 			return (status);
// 		if (!*head)
// 		{
// 			*head = new_node;
// 			current = *head;
// 		}
// 		else
// 		{
// 			current->next = new_node;
// 			current = current->next;
// 		}
// 		i++;
// 	}
// }

