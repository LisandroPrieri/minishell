// #include "../include/minishell.h"

// #define MINISHARED_PROMPT "\001\033[38;5;93m\002\033[48;5;214mM\001\033[0m\002 \001\033[38;5;99m\002\033[48;5;226mi\001\033[0m\002 \001\033[38;5;111m\002\033[48;5;190mn\001\033[0m\002 \001\033[38;5;63m\002\033[48;5;154mi\001\033[0m\002 \001\033[38;5;75m\002\033[48;5;118m_\001\033[0m\002 \001\033[38;5;81m\002\033[48;5;154ms\001\033[0m\002 \001\033[38;5;118m\002\033[48;5;75mh\001\033[0m\002 \001\033[38;5;154m\002\033[48;5;63ma\001\033[0m\002 \001\033[38;5;190m\002\033[48;5;111mr\001\033[0m\002 \001\033[38;5;226m\002\033[48;5;99me\001\033[0m\002 \001\033[38;5;214m\002\033[48;5;93md\001\033[0m\002: \001\033[0m\002"
// #define MINISHARED_PROMPT "\033[0;37m\033[45mM\033[0;37m\033[45mI\033[0;37m\033[45mN\033[0;37m\033[45mI\033[0;37m\033[45m_\033[0;37m\033[45mS\033[0;37m\033[45mH\033[0;37m\033[45mA\033[0;37m\033[45mR\033[0;37m\033[45mE\033[0;37m\033[45mD\033[0m: "
// #define MINISHARED_PROMPT "\033[1;33m\033[48;5;24mM\033[1;33m\033[48;5;24mI\033[1;33m\033[48;5;24mN\033[1;33m\033[48;5;24mI\033[1;33m\033[48;5;24m_\033[1;33m\033[48;5;24mS\033[1;33m\033[48;5;24mH\033[1;33m\033[48;5;24mA\033[1;33m\033[48;5;24mR\033[1;33m\033[48;5;24mE\033[1;33m\033[48;5;24mD\033[0m: "

// #define MINISHARED_PROMPT "\001\033[38;5;196m\002M\001\033[38;5;202m\002i\001\033[38;5;208m\002n\001\033[38;5;214m\002i\001\033[38;5;220m\002_\001\033[38;5;226m\002s\001\033[38;5;190m\002h\001\033[38;5;154m\002a\001\033[38;5;118m\002r\001\033[38;5;82m\002e\001\033[38;5;120m\002d\001\033[0m\002<ðŸ¤œ ðŸ¤›> \001\033[0m\002"
// #define MINISHARED_PROMPT "\001\033[38;5;93m\002M\001\033[38;5;99m\002i\001\033[38;5;111m\002n\001\033[38;5;63m\002i\001\033[38;5;75m\002_\001\033[38;5;81m\002s\001\033[38;5;118m\002h\001\033[38;5;154m\002a\001\033[38;5;190m\002r\001\033[38;5;226m\002e\001\033[38;5;214m\002d\001\033[0m\002<ðŸ¤œ ðŸ¤›> \001\033[0m\002"


/**
 * @brief Updates the PWD node,
 * and creates it if it was unset.
 * FOR THAT IT NEEDS A DOUBLE POINTER
 * AND TO PROPERLY UPDATE THE NODE IN THE FUNCTION,
 * WHICH THIS FUNCTION IS NOT DOING.
 * THIS FUNCTION WAS REMOVED BECAUSE AS IT IS, IT IS WRONG.
 * @param env_head The head node of the environment list.
 * @return 
 */
t_ecode	update_pwd(t_env *env_head)
{
	t_env	*pwd_node;
	char	*keyval;
	char	cwd[PATH_MAX];

	if (!env_head)
		return (NULL_ERROR);
	getcwd(cwd, PATH_MAX);
	pwd_node = find_env_node(env_head, "PWD");
	fprintf(stderr, "Does it ever reach this condition?\n");
	if (!pwd_node)
	{
		fprintf(stderr, "Does it ever reach this condition?\n");
		keyval = ft_strjoin("PWD", "=");
		if (!keyval)
			return (handle_perror("update_pwd"), MALLOC_ERROR);
		keyval = ft_strjoin_fs1(&keyval, cwd);
		if (!keyval)
			return (handle_perror("update_pwd"), MALLOC_ERROR);
		pwd_node = create_populated_env_node(keyval);
		if (!pwd_node)
			return (ft_free((void **) &keyval), handle_perror("update_pwd"), MALLOC_ERROR);
		return (ft_free((void **) &keyval), SUCCESS);
	}
	return (update_value_in_env_node(pwd_node, cwd));
}


t_ecode	open_redirections(t_shell *shell, t_cmd *cmd)
{
	if (!shell || !cmd)
		return (NULL_ERROR);
	while (cmd->redir)
	{
		if (cmd->redir->redir_id == HERE)
			cmd->redir->fd = ft_atoi(cmd->redir->file);
		else if (cmd->redir->redir_id == IN)
			cmd->redir->fd = open(cmd->redir->file, O_RDONLY);
		else if (cmd->redir->redir_id == OUT)
			cmd->redir->fd = open(cmd->redir->file, O_WRONLY | O_TRUNC | O_CREAT, 0644);
		else if (cmd->redir->redir_id == APP)
			cmd->redir->fd = open(cmd->redir->file, O_WRONLY | O_APPEND | O_CREAT, 0644);
		else
			//Run Alex's close all fd's and exit.
		if (cmd->redir->redir_id == HERE || cmd->redir->redir_id == IN)
		{
			if (cmd->latest_in != REDIR_INIT)
				close(cmd->latest_in); //Protect
			cmd->latest_in = cmd->redir->fd;
		}
		else if (cmd->redir->redir_id == OUT || cmd->redir->redir_id == APP)
		{
			if (cmd->latest_out != REDIR_INIT)
				close(cmd->latest_out); //Protect
			cmd->latest_out = cmd->redir->fd;
		}
		if (cmd->redir->fd == -1)
			//Perror, Alex and good bye.
		cmd->redir = cmd->redir->next;
	}
	return (SUCCESS);
}

// void	execute_single_command(t_shell *shell, t_cmd *cmd)
// {
// 	shell->parent = fork();
// 	if (shell->parent == -1)
// 		return ;
// 	else if (shell->parent == 0)
// 		run_child_single_command(shell, cmd);
// 	waitpid(shell->parent, &shell->status, 0);
// 	// printf("Finished waiting for children. Status: %d\n", shell->status);
// }

// static void	run_child_single_command(t_shell *shell, t_cmd *cmd)
// {
// 	char	*cmd_path;
// 	char	**env_array;

// 	// handle_redirections(shell, cmd);
// 	cmd_path = get_cmd_path(shell, shell->cmd_list->args[0]);
// 	env_array = create_env_array(shell->env_list);
// 	execve(cmd_path, cmd->args, env_array);
// }

// void	handle_redirections(t_shell *shell, t_cmd *cmd)
// {
// 	int	input_fd;

// 	close(shell->pipefd[READ_END]);
// 	input_fd = handle_input(shell, cmd);
// 	dup2(input_fd, STDIN_FILENO);
// 	close(input_fd);
// 	dup2(shell->pipefd[WRITE_END], STDOUT_FILENO);
// 	close(shell->pipefd[WRITE_END]);
// }

// int	handle_input(t_shell *shell, t_cmd *cmd)
// {
// 	t_redir	*iterator;
// 	char	*infile_name;
// 	int		infile_fd;

// 	(void) shell;
// 	if (!cmd || cmd->redir)
// 		return (0);
// 	iterator = cmd->redir;
// 	while (iterator->redir)
// 	{
// 		if (iterator->redir == IN || iterator->redir == HERE) //Change HERE to HDOC
// 			infile_name = iterator->file;
// 		iterator = iterator->next;
// 	}
// 	infile_fd = open(infile_name, O_CREAT);
// 	return (infile_fd);
// }

//	OLD ENV_INIT FUNCTION
t_ecode	init_env_list(t_env **head, char **envp)
{
	t_env		*current;
	t_env		*new_node;
	t_ecode		status;	
	size_t		i;

	if (!envp || !*envp)
		return (NULL_ERROR);
	i = 0;
	while (envp[i])
	{
		new_node = new_copied_env_node(envp[i], &status);
		if (status != SUCCESS)
			return (status);
		if (!*head)
		{
			*head = new_node;
			current = *head;
		}
		else
		{
			current->next = new_node;
			current = current->next;
		}
		i++;
	}
	return (SUCCESS);
}

static t_env	*new_copied_env_node(char *keyvalue, t_ecode *status)
{
	t_env	*new_node;

	*status = SUCCESS;
	new_node = new_env_node();
	if (!new_node)
	{
		*status = NEW_NODE_ERROR;
		return (NULL);
	}
	*status = copy_keyvalue_into_env_node(&new_node, keyvalue);
	if (*status != SUCCESS)
		return (NULL);
	return (new_node);
}

t_env	*new_populated_env_node(char *key, char *value)
{
	t_env	*new_node;
	
	new_node = new_env_node();
	if (!new_node)
		return (NULL);
	if (update_key_in_env_node(new_node, key))
	{
		ft_free((void **) &new_node);
		return (NULL);
	}
	if (update_value_in_env_node(new_node, value))
	{
		ft_free((void **) &new_node->key);
		ft_free((void **) &new_node->keyvalue);
		ft_free((void **) &new_node);
		return (NULL);
	}
	return (new_node);
}

// char	*get_value_from_keyvalue(char *keyvalue) // Old version
// {
// 	char	*value;
// 	int		i;
// 	int		value_len;
	

// 	if (!keyvalue || !keyvalue[0])
// 		return (NULL);
// 	i = 0;
// 	while (*keyvalue && *keyvalue != '=')
// 		keyvalue++;
// 	keyvalue++;
// 	value_len = ft_strlen(keyvalue);
// 	value = ft_calloc(value_len + 1, sizeof(char));
// 	if (!value)
// 		return (NULL);
// 	i = 0;
// 	while (i < value_len)
// 	{
// 		value[i] = keyvalue[i];
// 		i++;
// 	}
// 	value[i] = '\0';
// 	return (value);
// }

// t_ecode	update_oldpwd(t_env	*oldpwd_node, char *cwd)
// {
// 	if (!oldpwd_node)
// 	{
// 		oldpwd_node = new_populated_env_node("PWD", getcwd(NULL, PATH_MAX));
// 		if (!pwd_node)
// 			return (MALLOC_ERROR);
// 	}
// 	else
// 	{
// 		if (update_value_in_env_node(pwd_node, getcwd(NULL, PATH_MAX)))
// 			return (MALLOC_ERROR);
// 	}
// 	return (SUCCESS);
// }

// t_ecode update_key_in_env_node(t_env *node, char *key)
// {
// 	if (!node || !key)
// 		return (NULL_ERROR);
// 	if (node->key)
// 		ft_free((void **) &node->key);
// 	else
// 	{
// 		node->key = ft_strdup(key);
// 		if (!node->key)
// 			return (MALLOC_ERROR);
// 	}
// 	if (update_keyvalue_in_env_node(node))
// 		return (MALLOC_ERROR);
// 	return (SUCCESS);
// }


t_ecode	copy_keyvalue_into_env_node(t_env **new_node, char *keyvalue)
{
	t_ecode	status;

	(*new_node)->keyvalue = ft_strdup(keyvalue);
	if (!(*new_node)->keyvalue)
		return (MALLOC_ERROR);
	(*new_node)->key = get_key_from_keyvalue((*new_node)->keyvalue);
	if (!(*new_node)->key)
		return (MALLOC_ERROR);
	status = get_value_from_keyvalue((*new_node)->keyvalue, &(*new_node)->value);
	if (!(*new_node)->value)
		return (MALLOC_ERROR);
	(*new_node)->next = NULL;
	return (SUCCESS);
}

//FROM INIT_SHELL.c
// int	unset_env_var(char *key, t_env **env_list)  //builtin
// {
// 	int		key_len;
// 	t_env	*current;
// 	t_env	*temp_var;

// 	if (!key)
// 		return (-2); //malloc error
// 	current = *env_list;
// 	temp_var = NULL;
// 	key_len = ft_strlen(key);
// 	while (current != NULL && current->next != NULL)
// 	{
// 		if (ft_strncmp(current->next->key, key, key_len) == 0)
// 		{
// 			temp_var = current->next;
// 			current->next = temp_var->next;
// 			free_env_node(temp_var);
// 			return (0); //SUCCESS
// 		}
// 		current = current->next;
// 	}
// 	return (0); // variable name not found thus not unset! // SUCCESS
// }

// int	init_shell_update_SHLVL(t_env **env_list)
// {
// 	t_env	*shlvl_node;
// 	unsigned int	value;

// 	shlvl_node = get_env_node("SHLVL", *env_list);
// 	if (shlvl_node)
// 	{
// 		value = ft_atoi(shlvl_node->value) + 1;
// 		if (shlvl_node->value)
// 			free(shlvl_node->value);
// 		shlvl_node->value = ft_itoa(value);
// 		if (!shlvl_node->value)
// 			return (1);
// 		return (0);
// 	}
// 	shlvl_node = new_env_var("SHLVL=1");
// 	if (!shlvl_node)
// 		return (1);
// 	add_env_var_in_back(env_list, shlvl_node);
// 	return (0);
// }

// int	init_shell(char **envp, t_shell *shell)
// {
// 	t_env	*env_list;
// 	t_env	*env_var;
// 	int		i;

// 	env_list = NULL;
// 	i = 0;
// 	while (envp[i] != NULL)
// 	{
// 		env_var = new_env_var(envp[i]);
// 		if (!env_var)
// 			return (free_env_list(env_list), 1);
// 		add_env_var_in_back(&env_list, env_var);
// 		i++;
// 	}
// 	if (init_shell_update_SHLVL(&env_list))
// 		return (free_env_list(env_list), 1);
// 	unset_env_var("OLDPWD", &env_list);
// 	shell->env_list = env_list;
// 	return (0);
// }


//--------------------------


// char	*get_value_from_keyvalue(char *keyvalue)
// {
// 	char	*value;
// 	int		i;
// 	int		j;
// 	int		value_len;
	
// 	if (!keyvalue || !keyvalue[0])
// 		return (NULL);
// 	while (*keyvalue && *keyvalue != '=')
// 		keyvalue[i++];
// 	value_len = ft_strlen(keyvalue);
// 	value = ft_calloc(value_len, sizeof(char));
// 	if (!value)
// 		return (NULL);
// 	j = 0;
// 	keyvalue[i++];
// 	while (j < i)
// 	{
// 		value[j] = keyvalue[i + j];
// 		j++;
// 	}
// 	value[j] = '\0';
// 	return (value);
// }

// char	*get_key_from_keyvalue(char *keyvalue)
// {
// 	char	*key;
// 	int		i;
// 	int		j;

// 	if (!keyvalue || !keyvalue[0])
// 		return (NULL);
// 	i = 0;
// 	while (keyvalue[i] && keyvalue[i] != '=')
// 		i++;
// 	key = ft_calloc(i + 1, sizeof(char));
// 	if (!key)
// 		return (NULL);
// 	j = 0;
// 	while (j < i)
// 	{
// 		key[j] = keyvalue[j];
// 		j++;
// 	}
// 	key[j] = '\0';
// 	return (key);
// }


// t_ecode	copy_keyvalue_into_env_node(t_env **new_node, char *keyvalue)
// {
// 	(*new_node)->keyvalue = ft_strdup(keyvalue);
// 	if (!(*new_node)->keyvalue)
// 		return (MALLOC_ERROR);
// 	(*new_node)->key = get_key_from_keyvalue((*new_node)->keyvalue);
// 	if (!(*new_node)->key)
// 		return (MALLOC_ERROR);
// 	(*new_node)->value = get_value_from_keyvalue((*new_node)->keyvalue);
// 	if (!(*new_node)->value)
// 		return (MALLOC_ERROR);
// 	(*new_node)->next = NULL;
// 	return (SUCCESS);
// }

// t_env	*new_env_node(void)
// {
// 	t_env	*new_node;
	
// 	new_node = ft_calloc(1, sizeof(t_env));
// 	if (!new_node)
// 		return (NULL);
// 	new_node->keyvalue = NULL;
// 	new_node->key = NULL;
// 	new_node->value = NULL;
// 	return (new_node);
// }

// ssize_t	count_envp_keys(char **envp)
// {
// 	int	i;

// 	if (!envp || !*envp)
// 		return (-1);
// 	i = 0;
// 	while (envp[i])
// 		i++;
// 	return (i);
// }

// static t_env	*new_copied_env_node(char *keyvalue, t_ecode *status)
// {
// 	t_env	*new_node;

// 	*status = SUCCESS;
// 	new_node = new_env_node();
// 	if (!new_node)
// 	{
// 		*status = NEW_NODE_ERROR;
// 		return (NULL);
// 	}
// 	*status = copy_keyvalue_into_env_node(&new_node, keyvalue);
// 	if (*status != SUCCESS)
// 		return (NULL);
// 	return (new_node);
// }

// t_ecode	init_env_list(t_env **head, char **envp)
// {
// 	t_env		*current;
// 	t_env		*new_node;
// 	t_ecode	status;	
// 	size_t		i;

// 	if (!envp || !*envp)
// 		return (NULL_ERROR);
// 	i = 0;
// 	while (envp[i])
// 	{
// 		new_node = new_copied_env_node(envp[i], &status);
// 		if (status != SUCCESS)
// 			return (status);
// 		if (!*head)
// 		{
// 			*head = new_node;
// 			current = *head;
// 		}
// 		else
// 		{
// 			current->next = new_node;
// 			current = current->next;
// 		}
// 		i++;
// 	}
// }

// t_ecode	curpath_trim(char **curpath) //Is this the format of the old version or the new?
// {
// 	t_curpath	*final_dirs;
// 	char 		**dirs;
// 	t_ecode		status;

// 	// printf("In curpath_trim, curpath: %s\n", *curpath);
// 	final_dirs = NULL;
// 	dirs = NULL;
// 	status = init_and_populate_curpath_list(curpath, &dirs, &final_dirs);
// 	if (status != SUCCESS)
// 		return (status);
// 	status = parse_curpath_dirs(&final_dirs);

// 	curpath_print(final_dirs);

// 	*curpath = curpath_concat(final_dirs);
// 	ft_free_2d((void ***) &dirs);
// 	if (final_dirs)
// 		curpath_del_list(&final_dirs);
// 	return (SUCCESS);
// }

// //Fix the segfault here.
// t_ecode	init_and_populate_curpath_list(char **curpath, char ***dirs, t_curpath **final_dirs)
// {
// 	t_ecode	status;
// 	int		i;
	
// 	*dirs = ft_split(*curpath, '/');
// 	if (!dirs)
// 		return (NULL_ARRAY);
// 	create_and_add_back_curpath_node(final_dirs, "/");
// 	i = 0;
// 	while ((*dirs)[i])
// 	{
// 		// printf("In init_and_populate_curpath: dir[%d] is: %s\n", i, (*dirs)[i]);
// 		status = create_and_add_back_curpath_node(final_dirs, (*dirs)[i]);
// 		if (status)
// 			return (status);
// 		i++;
// 	}
// 	// printf("In init_and_populate_curpath:\n");
// 	// curpath_print(*final_dirs);
// 	// ft_free((void **) curpath); //Note that there are 2 returns before this, that don't free curpath. Check if it is handled.
// 	return (SUCCESS);
// }


// //STOPPED HERE...
// t_ecode	parse_curpath_dirs(t_curpath **final_dirs)
// {
// 	t_curpath	*iterator;
// 	t_curpath	*current;
// 	t_ecode		status;
// 	size_t		dir_len;

// 	status = SUCCESS;
// 	iterator = *final_dirs;
// 	while (iterator)
// 	{
// 		if (!iterator->dir)
// 			printf("While parsing curpath, no dir was found in this node.\n");
// 		dir_len = ft_strlen(iterator->dir);
// 		if (iterator->dir && !ft_strncmp(iterator->dir, ".", dir_len))
// 		{
// 			printf("Removing . from curpath\n");
// 			current = iterator;
// 			iterator = iterator->next;
// 			remove_curpath_node(final_dirs, &current);
// 			continue ;
// 		}
// 		else if (iterator->dir && !ft_strncmp(iterator->dir, "..", dir_len))
// 		{
// 			printf("Removing .. from curpath\n");
// 			if (iterator->previous && !ft_strncmp(iterator->previous->dir, "/", ft_strlen(iterator->previous->dir)))
// 			{
// 				current = iterator->previous;
// 				remove_curpath_node(final_dirs, &current);
// 				current = iterator;
// 			}
// 			else
// 				current = iterator;
// 			iterator = iterator->next;
// 			remove_curpath_node(final_dirs, &current);
// 			// remove_curpath_node(final_dirs, &current); //Check if the path is actually valid.
// 			continue ;
// 		}
// 		iterator = iterator->next;
// 	}
// 	curpath_print(*final_dirs);
// 	return (SUCCESS);
// }

// char	*curpath_concat(t_curpath *head)
// {
// 	char	*temp_curpath;
// 	t_ecode	status;
	
// 	if (!head || !head->dir)
// 		return (NULL);
// 	// printf("head->dir in curpath_concat: %s\n", head->dir);
// 	temp_curpath = ft_strdup(head->dir);
// 	if (!temp_curpath)
// 		return (NULL);
// 	head = head->next;
// 	// printf("temp_curpath in curpath_concat: %s\n", temp_curpath);
// 	while (head && head->dir)
// 	{
		
// 		temp_curpath = ft_strjoin_fs1(&temp_curpath, head->dir);
// 		if (!temp_curpath)
// 			return (NULL);
// 		status = append_suffix(&temp_curpath, "/", false);
// 		if (status)
// 			return (NULL);
// 		head = head->next;
// 		// printf("temp_curpath in curpath_concat: %s\n", temp_curpath);
// 	}
// 	// printf("Returning temp_curpath in curpath_concat: %s\n", temp_curpath);
// 	return (temp_curpath);
// }

// t_ecode	curpath_prepare(char **curpath, char *directory, char *cwd)
// {
// 	int		status;
	
// 	status = append_suffix(&cwd, "/", false); //This affects the local cwd variable, right?
// 	// printf("In curpath_prepare: cwd: %s\n", cwd);
// 	if (status == MALLOC_ERROR)
// 		return (MALLOC_ERROR);
// 	if (directory[0] != '/')
// 		*curpath = ft_strjoin(cwd, directory);
// 	else
// 		*curpath = ft_strdup(directory);
// 	if (!curpath)
// 		return (MALLOC_ERROR);
// 	else
// 		return (SUCCESS);
// }


// t_ecode	remove_previous_dir(t_curpath **final_dirs, char ***dirs, int *i)
// {
// 	char	*temp_curpath;
// 	t_ecode	status;

// 	temp_curpath = curpath_concat(*final_dirs);
// 	if (!temp_curpath)
// 		return (MALLOC_ERROR);
// 	printf("temp_curpath in remove_prev_dir: %s\n", temp_curpath);
// 	status = curpath_check_access(temp_curpath);
// 	ft_free((void **) &temp_curpath);
// 	if (status)
// 	{
// 		ft_free_2d((void ***) dirs);
// 		if (*final_dirs)
// 			curpath_del_list(final_dirs);
// 		return (status);
// 	}
// 	curpath_del_last(final_dirs);
// 	*i += 1;
// 	return (SUCCESS);
// }

// t_ecode	check_access_and_add_back(t_curpath **final_dirs, char ***dirs, int *i)
// {
// 	char	*curpath;
// 	t_ecode	status;
	
// 	// curpath = NULL;
// 	// if (final_dirs && *final_dirs && (*final_dirs)->dir)
// 	curpath = curpath_concat(*final_dirs);
// 	status = curpath_check_access(curpath);
// 	ft_free((void **) &curpath);
// 	if (status)
// 	{
// 		ft_free_2d((void ***) dirs);
// 		if (*final_dirs)
// 			curpath_del_list(final_dirs);
// 		return (status);
// 	}
// 	else
// 	{
// 		if (!*final_dirs)
// 		{
// 			status = create_and_add_back_curpath_node(final_dirs, "/");
// 			if (status)
// 				return (status);
// 		}
// 		status = create_and_add_back_curpath_node(final_dirs, (*dirs)[*i]);
// 		if (status)
// 			return (status);
// 	}
// 	*i += 1;
// 	return (SUCCESS);
// }





// /** NOTE TO SELF
//  * I need to take a look at all the functions and distinguish or discriminate between
//  * those that take arguments for freeing everything (basically error handling within the function)
//  * and those that don't.
//  * In the end I have to decide for one way of writing functions or the other.
// */




// // t_ecode	curpath_trim(char **curpath)
// // {
// // 	t_curpath	*final_dirs;
// // 	char 		**dirs;
// // 	int			i;
// // 	int			status;

// // 	status = init_curpath_dirs(curpath, &dirs, &final_dirs);
// // 	if (status != SUCCESS)
// // 		return (status);
// // 	i = 0;
// // 	while (dirs[i])
// // 	{
// // 		if (dirs[i][0] == '.' && dirs[i][1] == '/0')
// // 		{
// // 			i++;
// // 			continue ;
// // 		}
// // 		else if (dirs[i][0] == '.' && dirs[i][1] == '.' && dirs[i][2] == '/0')
// // 		{
// // 			*curpath = curpath_concat(final_dirs);
// // 			status = curpath_check_access(*curpath);
// // 			ft_free((void **) curpath);
// // 			if (status)
// // 			{
// // 				ft_free_2d((void ***) &dirs);
// // 				if (final_dirs)
// // 					curpath_del_list(&final_dirs);
// // 				return (status);
// // 			}
// // 			curpath_del_last(&final_dirs);
// // 			i++;
// // 			continue ;
// // 		}
// // 		*curpath = curpath_concat(final_dirs);
// // 		status = curpath_check_access(*curpath);
// // 		ft_free((void **) curpath);
// // 		if (status)
// // 		{
// // 			ft_free_2d((void ***) &dirs);
// // 			if (final_dirs)
// // 				curpath_del_list(&final_dirs);
// // 			return (status);
// // 		}
// // 		else
// // 		{
// // 			if (!final_dirs)
// // 			{
// // 				status = create_and_add_back_curpath_node(&final_dirs, &dirs, "/");
// // 				if (status)
// // 					return (status);
// // 			}
// // 			status = create_and_add_back_curpath_node(&final_dirs, &dirs, dirs[i]);
// // 			if (status)
// // 				return (status);
// // 		}
// // 		i++;
// // 	}
// // 	*curpath = curpath_concat(final_dirs);
// // 	ft_free_2d((void ***) &dirs);
// // 	if (final_dirs)
// // 		curpath_del_list(&final_dirs);
// // 	return (*curpath);
// // }

// t_ecode	create_and_add_back_curpath_node(t_curpath **head, char *directory)
// {
// 	t_curpath	*new;

// 	new = curpath_new_node(directory);
// 	if (!new)
// 		return (MALLOC_ERROR);
// 	curpath_add_back(head, new);
// 	return (SUCCESS);
// }

// t_curpath	*curpath_new_node(char *dir)
// {
// 	t_curpath	*new_node;

// 	new_node = (t_curpath *) malloc(sizeof(t_curpath));
// 	if (!new_node)
// 		return (NULL);
// 	new_node->dir = ft_strdup(dir);
// 	if (!new_node->dir)
// 	{
// 		ft_free((void **) &new_node);
// 		return (NULL);
// 	}
// 	new_node->previous = NULL;
// 	new_node->next = NULL;
// 	return (new_node);
// }

// void	curpath_add_back(t_curpath **head, t_curpath *new)
// {
// 	t_curpath	*iterator;

// 	if (!new)
// 		return ;
// 	if (!*head)
// 	{
// 		*head = new;
// 		(*head)->previous = NULL;
// 	}
// 	else
// 	{
// 		iterator = get_last_curpath_node(*head);
// 		iterator->next = new;
// 		iterator->next->previous = iterator;
// 	}
// }

// t_ecode	remove_curpath_node(t_curpath **head, t_curpath **node)
// {
// 	t_curpath	*previous_node;
// 	// t_curpath	*next_node;

// 	if (!*node || !*head)
// 		return (NULL_NODE);
// 	previous_node = (*node)->previous;
// 	curpath_del_node(node);
// 	// *node = previous_node;
// 	return (SUCCESS);
// }

// void	curpath_del_node(t_curpath **node)
// {
// 	if (!*node)
// 		return ;
// 	if (*node && (*node)->dir)
// 		ft_free((void **) &(*node)->dir);
// 	if ((*node)->previous)
// 	{
// 		// printf("removing previous node in curpath_del_node\n");
// 		(*node)->previous->next = (*node)->next;
// 	}
// 	if ((*node)->next)
// 	{
// 		// printf("removing next node in curpath_del_node\n");
// 		(*node)->next->previous = (*node)->previous;
// 	}
// 	free(*node);
// 	*node = NULL;
// 	return ;
// }

// void	curpath_del_node_definitely(t_curpath **node)
// {
// 	if (!*node)
// 		return ;
// 	if (*node && (*node)->dir)
// 		ft_free((void **) &(*node)->dir);
// 	free(*node);
// 	*node = NULL;
// 	return ;
// }

// void	curpath_del_list(t_curpath **head) //Maybe reimplement taking a function ptr as arg, a function that handles the freeing of the nodes.
// {
// 	t_curpath	*iterator;
// 	t_curpath	*current;

// 	if (!*head)
// 		return ;
// 	current = *head;
// 	iterator = *head;
// 	while (iterator)
// 	{
// 		iterator = iterator->next;
// 		curpath_del_node_definitely(&current);
// 		current = iterator;
// 	}
// }

// t_curpath	*get_last_curpath_node(t_curpath *head)
// {
// 	t_curpath	*iterator;

// 	if (!head)
// 		return (NULL);
// 	iterator = head;
// 	while (iterator && iterator->next)
// 		iterator = iterator->next;
// 	return (iterator);
// }

// void	curpath_del_last(t_curpath **head)
// {
// 	t_curpath	*iterator;

// 	if (!*head)
// 		return ;
// 	iterator = get_last_curpath_node(*head)->previous;
// 	if (!iterator)
// 		return ;
// 	curpath_del_node_definitely(&iterator->next);
// 	iterator->next = NULL;
// 	return ;	
// }

// int	curpath_check_access(char *curpath)
// {
// 	int	e_status;

// 	if (!curpath)
// 		return (1);
// 	e_status = access(curpath, F_OK);
// 	if (e_status)
// 		return (e_status);
// 	e_status = access(curpath, X_OK);
// 	if (e_status)
// 		return (e_status);
// 	return (0);
// }

// t_ecode	curpath_check_access_and_chdir(char *curpath)
// {
// 	t_ecode	e_status;

// 	e_status = curpath_check_access(curpath);
// 	if (e_status)
// 		return (ACCESS_ERROR);
// 	e_status = chdir(curpath);
// 	if (e_status)
// 		return (CHDIR_ERROR);
// 	return (SUCCESS);
// }

// void	curpath_print(t_curpath *curpath)
// {
// 	int	counter;

// 	if (!curpath)
// 	{
// 		printf("The curpath struct is null, can't print it.\n");
// 		return ;
// 	}
// 	counter = 0;
// 	while (curpath)
// 	{
// 		if (curpath->dir)
// 			printf("Curpath dir[%d]: %s\n", counter, curpath->dir);
// 		else
// 			printf("Curpath dir[%d] is NULL!\n", counter);
// 		curpath = curpath->next;
// 		counter++;
// 	}
// 	return ;
// }

// typedef enum flags
// {
// 	NULL_FLAG = 0,
// 	STATUS_FLAG
// }	t_flags;

// t_ecode	chdir_cwd(char *directory, int *null_flag)
// {
// 	char	*curpath;

// 	*null_flag = 1;
// 	curpath = ft_strjoin("./", directory);
// 	if (!curpath)
// 		return (ft_free((void **) &curpath), MALLOC_ERROR);
// 	if (curpath_check_access(curpath))
// 		return (ft_free((void **) &curpath), PROCEED);
// 	if (chdir(curpath))
// 		return (ft_free((void **) &curpath), PROCEED);
// 	else
// 		return (ft_free((void **) &curpath), SUCCESS);
// }

// t_ecode chdir_cdpath_value(char **curpath, char *directory)
// {
// 	t_ecode	status;

// 	status = append_suffix(curpath, "/", false);
// 	if (status)
// 		return (MALLOC_ERROR);
// 	*curpath = ft_strjoin_fs1(curpath, directory);
// 	if (!*curpath)
// 		return (MALLOC_ERROR);
// 	status = curpath_check_access(*curpath);
// 	if (status)
// 		return (ft_free((void **) curpath), PROCEED);
// 	status = chdir(*curpath);
// 	if (status)
// 		return (ft_free((void **) curpath), PROCEED);
// 	else
// 		return (ft_free((void **) curpath), SUCCESS);
// }

// t_ecode	loop_cdpath_values(char ***values, char *directory)
// {
// 	char	*curpath;
// 	int		i;
// 	int		flag[2];

// 	i = 0;
// 	flag[NULL_FLAG] = 0;
// 	flag[STATUS_FLAG] = 0;
// 	while ((*values)[i])
// 	{
// 		curpath = ft_strdup((*values)[i]);
// 		if (!curpath && flag[NULL_FLAG])
// 		{
// 			flag[STATUS_FLAG] = chdir_cwd(directory, &flag[NULL_FLAG]);
// 			if (flag[STATUS_FLAG] == PROCEED)
// 			{
// 				i++;
// 				continue ;
// 			}
// 			else
// 				return (ft_free_2d((void ***) values), flag[STATUS_FLAG]);
// 		}
// 		else if (!curpath && flag[NULL_FLAG])
// 		{
// 			i++;
// 			continue;
// 		}
// 		flag[STATUS_FLAG] = chdir_cdpath_value(&curpath, directory);
// 		if (flag[STATUS_FLAG] == PROCEED)
// 		{
// 			ft_free((void **) &curpath);
// 			i++;
// 			continue ;
// 		}
// 		else
// 			return (ft_free((void **) &curpath),
// 				ft_free_2d((void ***) &values), flag[STATUS_FLAG]);
// 	}
// 	return (ft_free_2d((void ***) &values), PROCEED);
// }

// typedef	struct s_cd_struct
// {

// }	t_cd_struct;

// t_ecode	chdir_curpath(t_shell **shell, char **curpath, char **cwd)
// {
// 	int	status;

// 	(void) shell;
// 	status = chdir(*curpath);
// 	ft_free((void **) curpath);
// 	ft_free((void **) cwd);
// 	printf("chdir status: %d\n", status);
// 	return (0);
// }

// t_ecode	chdir_tilde(t_env *env_list, char **cwd)
// {
// 	t_env	*home_node;
// 	char	*home_path;
// 	int		status;

// 	home_node = find_env_node(env_list, "HOME");
// 	if (home_node)
// 		return (chdir_home(env_list, cwd));
// 	home_path = get_home();
// 	if (!home_path)
// 	{
// 		//PRINT mini_shared: cd: HOME not set.
// 		return (FAILURE);
// 	}
// 	status = chdir(home_path);
// 	ft_free((void **) &home_path);
// 	//CALL FUNCTION TO UPDATE PWD, OLDPWD and free cwd.
// 	return (status);
// }

// t_ecode	chdir_dash(t_env *env_list, char **cwd)
// {
// 	t_env	*oldpwd_node;
// 	int		status;

// 	oldpwd_node = find_env_node(env_list, "OLDPWD");
// 	if (!oldpwd_node)
// 	{
// 		//PRINT mini_shared: cd: OLDPWD not set.
// 		return (FAILURE);
// 	}
// 	status = chdir(oldpwd_node->value);
// 	(void) cwd;
// 	//CALL FUNCTION TO UPDATE PWD, OLDPWD and free cwd.
// 	return (status);
// }

// //For ~ use getenv("HOME");
// t_ecode	builtin_cd(t_shell **shell, char *directory)
// {
// 	char		*curpath;
// 	char		*cwd;
// 	t_ecode		status;

// 	curpath = NULL;
// 	cwd = getcwd(NULL, PATH_MAX);
// 	if (!cwd)
// 		return (CWD_ERROR);
// 	if (!directory || !ft_strncmp(directory, "--", ft_strlen(directory)))
// 		return (chdir_home((*shell)->env_list, &cwd));
// 	else if (!ft_strncmp(directory, "~", ft_strlen(directory)))
// 	{
// 		status = chdir_tilde((*shell)->env_list, &cwd);
// 		return (status);
// 	}
// 	else if (!ft_strncmp(directory, "-", ft_strlen(directory)))
// 	{
// 		status = chdir_dash((*shell)->env_list, &cwd);
// 		return (status);
// 	}
// 	else if (is_dir_prefix_valid_for_cdpath(directory))
// 	{
// 		status = chdir_cdpath(shell, directory);
// 		if (!status)
// 			return (SUCCESS);
// 		else if (status == MALLOC_ERROR)
// 			return (FAILURE); //And free everything... Rather 'exit' than return.
// 	}
// 	// curpath = ft_strdup(directory);
// 	// if (!curpath)
// 	// 	return (MALLOC_ERROR);
// 	// if (ft_strncmp(curpath, "/", ft_strlen(curpath)))
// 	// {

// 	// }
// 	status = curpath_prepare(&curpath, directory, cwd);
// 	if (status)
// 		return (status);
// 	status = curpath_trim(&curpath); // I think I have to append cwd to curpath, otherwise .. doesn't work.
// 	if (status)
// 		return (status); //Free everything.
// 	printf("Curpath in builtin_cd: %s\n", curpath);
// 	return (chdir_curpath(shell, &curpath, &cwd));
// }

// t_ecode	chdir_home(t_env *env_head, char **cwd)
// {
// 	t_env	*home_node;
// 	t_ecode	exit_status;

// 	home_node = find_env_node(env_head, "HOME");
// 	if (!home_node || !home_node->value)
// 	{
// 		// PRINT ERROR
// 		ft_free((void **) cwd);
// 		return (HOME_ERROR);
// 	}
// 	else
// 	{
// 		exit_status = chdir(home_node->value);
// 		if (exit_status)
// 			return (CHDIR_ERROR);
// 		update_env_node(env_head, "PWD", getcwd(NULL, PATH_MAX), true);
// 		update_env_node(env_head, "OLDPWD", *cwd, true);
// 		ft_free((void **) cwd);
// 		return (SUCCESS);
// 	}
// }

// t_ecode	chdir_cdpath(t_shell **shell, char *directory)
// {
// 	t_env	*cdpath_node;
// 	char	**values;
// 	t_ecode	status;

// 	cdpath_node = find_env_node((*shell)->env_list, "CDPATH");
// 	if (!cdpath_node || !cdpath_node->value)
// 		return (CDPATH_NULL);
// 	values = ft_split(cdpath_node->value, ':');
// 	if (!values)
// 		return (MALLOC_ERROR);
// 	status = loop_cdpath_values(&values, directory);
// 	return (status);
// }

// void	free_array_pipex(char **arr)
// {
// 	int	i;

// 	i = 0;
// 	while (arr && arr[i])
// 	{
// 		free(arr[i]);
// 		i++;
// 	}
// 	free(arr);
// }

// void	clean_nicely(t_pipex *pipex)
// {
// 	if (pipex->cmd1)
// 		free_array_pipex(pipex->cmd1);
// 	if (pipex->cmd2)
// 		free_array_pipex(pipex->cmd2);
// 	free_array_pipex(pipex->possible_paths);
// }

// char	*ft_strjoin_fs1pipex(char *s1, char const *s2)
// {
// 	char	*dst;
// 	size_t	ls1;
// 	size_t	ls2;

// 	if (!s1)
// 		return (NULL);
// 	if (!s2)
// 		return (s1);
// 	ls1 = ft_strlen(s1);
// 	ls2 // Construct full path
// 		temp = ft_strjoin(pipex->possible_paths[i], "/");
// 		char *full_cmd = ft_strjoin(temp, *cmd);
// 		free(temp);
// 		if (!full_cmd)
// 		{
// 			write(2, "error: Unable to allocate dynamic memory\n", 41);
// 			clean_nicely(pipex);
// 			exit(EXIT_FAILURE);
// 		}
		
// 		// Check access to the path
// 		if (access(full_cmd, X_OK | F_OK) == 0)
// 		{
// 			free(*cmd);
// 			*cmd = full_cmd;
// 			return (1);
// 		}

// 		free(full_cmd);
// 		i++;
// 	}
// 	fprintf(stderr, "Command not found in any path\n");
// 	return (0);
// }

// void first_child(t_pipex *pipex, t_shell *shell, t_tree *tree_node, char **envp)
// {
// 	char **argv;
// 	int is_found = 0;

// 	argv = make_cmd(shell, tree_node->left->start_token, tree_node->left->end_token)->args;
// 	fprintf(stderr, "cmd1[0] %s\n", argv[0]);
// 	if (access(argv[0], X_OK | F_OK) == 0)
// 		is_found = 1;
// 	else
// 	{
// 		is_found = find_correct_path(pipex, argv);
// 	}
// 	close (pipex->fd[READ_END]);

// 	if (dup2(pipex->fd[WRITE_END], STDOUT_FILENO) == -1)
// 	{
// 		perror("dup2 failed for stdout");
// 		clean_nicely(pipex);
// 	}

// 	if (close(pipex->fd[WRITE_END]) == -1)
// 		perror("close");

// 	if (is_found)
// 	{
// 		fprintf (stderr, "execving cmd1 %s\n", argv[0]);
// 		execve(argv[0], argv, envp);
// 		exit(EXIT_FAILURE);
// 	}

// 	ft_putstr_fd(pipex->cmd1[0], 2);
// 	write(2, ": command not found\n", 20);
// 	clean_nicely(pipex);
// 	exit(127);
// }

// void second_child(t_pipex *pipex, t_shell *shell, t_tree *tree_node, char **envp)
// {
// 	int status;
// 	char **argv;
// 	if (dup2(pipex->fd[READ_END], STDIN_FILENO) == -1)
// 	{
// 		fprintf(stderr, "dup2 failed for stdin");
// 		clean_nicely(pipex);
// 		exit(EXIT_FAILURE);
// 	}
// 	close_fds(pipex->fd[READ_END], pipex->fd[WRITE_END]);
	
// 	pid_t pid3 = fork();
// 	if (pid3 == 0)
// 	{
// 		argv = make_cmd(shell, tree_node->right->left->start_token, tree_node->right->left->end_token)->args;
// 		fprintf(stderr, "cmd2[0] %s\n", argv[0]);
// 		int is_found = find_correct_path(pipex, argv);
// 		fprintf (stderr, "is found? %d\n", is_found);
// 		if (is_found)
// 		{
// 			fprintf (stderr, "execving cmd2 %s\n", argv[0]);
// 			execve(argv[0], argv, envp);
// 			exit(EXIT_FAILURE);
// 		}
// 		else
// 		{
// 			fprintf (stderr, "failed cmd2\n");
// 			exit(EXIT_FAILURE);
// 		}
// 	}
	
// 	// Wait for the first child process to finish
// 	if (waitpid(pid3, &status, 0) == -1)
// 	{
// 		perror("waitpid failed");
// 	}
	
// 	// Check if the child process terminated normally
// 	if (WIFEXITED(status))
// 	{
// 		fprintf(stderr, "status of cmd2 is %d\n", WEXITSTATUS(status));
// 	}
// 	else
// 	{
// 		fprintf(stderr, "cmd2 did not terminate normally\n");
// 	}

// 	pid_t pid4 = fork();
// 	if (pid4 == 0)
// 	{
// 		argv = make_cmd(shell, tree_node->right->right->start_token, tree_node->right->right->end_token)->args;
// 		fprintf(stderr, "cmd3[0] %s\n", argv[0]);
// 		int is_found = find_correct_path(pipex, argv);
// 		if (is_found)
// 		{
// 			fprintf (stderr, "execving cmd3 %s\n", argv[0]);
// 			execve(argv[0], argv, envp);
// 		}
// 		else
// 		{
// 			fprintf(stderr, "failed cmd3\n");
// 			exit(EXIT_FAILURE);
// 		}
// 	}
// 	wait(NULL);
// 	exit(EXIT_SUCCESS);
// }

// char *locate_env_path(t_env **envp)
// {
// 	t_env *current = *envp;  // Start at the head of the list

// 	// Traverse the linked list
// 	while (current)
// 	{
// 		// Compare the key portion with "PATH"
// 		if (ft_strncmp("PATH", current->keyvalue, 4) == 0)
// 			return (current->keyvalue);  // Return the actual string
		
// 		current = current->next;  // Move to the next node
// 	}
// 	return (NULL);  // If no "PATH" variable was found
// }

// void find_possible_paths(t_pipex *pipex, t_env **envp)
// {
// 	char *envp_path;

// 	envp_path = locate_env_path(envp);
// 	if (!envp_path)
// 		return;

// 	// Split the path and store it in pipex->possible_paths
// 	pipex->possible_paths = ft_split(envp_path + 5, ':');
	
// 	// Check if ft_split was successful
// 	if (!pipex->possible_paths)
// 	{
// 		// Handle error (e.g., log or return)
// 		return;
// 	}
// }


// void free_array(char **arr)
// {
// 	int i = 0;

// 	while (arr && arr[i])
// 	{
// 		free(arr[i]);
// 		i++;
// 	}
// 	free(arr);
// }

// // int create_pipe(t_pipex *pipex, t_shell *shell, t_tree *tree_node, t_env **envp)
// int create_pipe(t_pipex *pipex, t_shell *shell, t_tree *tree_node, char **envp)
// {
// 	if (pipe(pipex->fd) < 0)
// 		clean_nicely(pipex);

// 	pipex->pid1 = fork();
// 	if (pipex->pid1 == -1)
// 	{
// 		perror("First fork");
// 		clean_nicely(pipex);
// 		exit(EXIT_FAILURE);
// 	}
// 	else if (pipex->pid1 == 0)
// 		first_child(pipex, shell, tree_node, envp);

// 	pipex->pid2 = fork();
// 	if (pipex->pid2 == -1)
// 	{
// 		perror("Second fork");
// 		clean_nicely(pipex);
// 		exit(EXIT_FAILURE);
// 	}
// 	else if (pipex->pid2 == 0)
// 		second_child(pipex, shell, tree_node, envp);
// 	close_fds(pipex->fd[0], pipex->fd[1]);
// 	while (wait(NULL) != -1)
// 		;
// 	return (SUCCESS);
// }

// int handle_pipe_subtree(t_shell *shell, t_tree *tree_node)
// {
// 	t_pipex pipex;
// 	char **env_array;
	
// 	env_array = create_env_array(shell->env_list);
// 	ft_bzero(&pipex, sizeof(t_pipex));
// 	find_possible_paths(&pipex, &shell->env_list);
// 	create_pipe(&pipex, shell, tree_node, env_array);
// 	clean_nicely(&pipex);
// 	return (0);
// }= ft_strlen(s2);
// 	dst = malloc(sizeof(char) * (ls1 + ls2 + 1));
// 	if (!dst)
// 		return (free(s1), NULL);
// 	ft_strlcpy(dst, s1, (ls1 + 1));
// 	ft_strlcat(dst, s2, (ls1 + ls2 + 1));
// 	free(s1);
// 	return (dst);
// }

// int find_correct_path(t_pipex *pipex, char **cmd)
// {
// 	char *temp;
// 	int i = 0;

// 	if (!pipex->possible_paths || *cmd == NULL || cmd == NULL)
// 		return (0);

// 	while (pipex->possible_paths[i])
// 	{
// 		//fprintf(stderr, "Checking path: %s/%s\n", pipex->possible_paths[i], *cmd);
		
// 		// Construct full path
// 		temp = ft_strjoin(pipex->possible_paths[i], "/");
// 		char *full_cmd = ft_strjoin(temp, *cmd);
// 		free(temp);
// 		if (!full_cmd)
// 		{
// 			write(2, "error: Unable to allocate dynamic memory\n", 41);
// 			clean_nicely(pipex);
// 			exit(EXIT_FAILURE);
// 		}
		
// 		// Check access to the path
// 		if (access(full_cmd, X_OK | F_OK) == 0)
// 		{
// 			free(*cmd);
// 			*cmd = full_cmd;
// 			return (1);
// 		}

// 		free(full_cmd);
// 		i++;
// 	}
// 	fprintf(stderr, "Command not found in any path\n");
// 	return (0);
// }

// void first_child(t_pipex *pipex, t_shell *shell, t_tree *tree_node, char **envp)
// {
// 	char **argv;
// 	int is_found = 0;

// 	argv = make_cmd(shell, tree_node->left->start_token, tree_node->left->end_token)->args;
// 	fprintf(stderr, "cmd1[0] %s\n", argv[0]);
// 	if (access(argv[0], X_OK | F_OK) == 0)
// 		is_found = 1;
// 	else
// 	{
// 		is_found = find_correct_path(pipex, argv);
// 	}
// 	close (pipex->fd[READ_END]);

// 	if (dup2(pipex->fd[WRITE_END], STDOUT_FILENO) == -1)
// 	{
// 		perror("dup2 failed for stdout");
// 		clean_nicely(pipex);
// 	}

// 	if (close(pipex->fd[WRITE_END]) == -1)
// 		perror("close");

// 	if (is_found)
// 	{
// 		fprintf (stderr, "execving cmd1 %s\n", argv[0]);
// 		execve(argv[0], argv, envp);
// 		exit(EXIT_FAILURE);
// 	}

// 	ft_putstr_fd(pipex->cmd1[0], 2);
// 	write(2, ": command not found\n", 20);
// 	clean_nicely(pipex);
// 	exit(127);
// }

// void second_child(t_pipex *pipex, t_shell *shell, t_tree *tree_node, char **envp)
// {
// 	int status;
// 	char **argv;
// 	if (dup2(pipex->fd[READ_END], STDIN_FILENO) == -1)
// 	{
// 		fprintf(stderr, "dup2 failed for stdin");
// 		clean_nicely(pipex);
// 		exit(EXIT_FAILURE);
// 	}
// 	close_fds(pipex->fd[READ_END], pipex->fd[WRITE_END]);
	
// 	pid_t pid3 = fork();
// 	if (pid3 == 0)
// 	{
// 		argv = make_cmd(shell, tree_node->right->left->start_token, tree_node->right->left->end_token)->args;
// 		fprintf(stderr, "cmd2[0] %s\n", argv[0]);
// 		int is_found = find_correct_path(pipex, argv);
// 		fprintf (stderr, "is found? %d\n", is_found);
// 		if (is_found)
// 		{
// 			fprintf (stderr, "execving cmd2 %s\n", argv[0]);
// 			execve(argv[0], argv, envp);
// 			exit(EXIT_FAILURE);
// 		}
// 		else
// 		{
// 			fprintf (stderr, "failed cmd2\n");
// 			exit(EXIT_FAILURE);
// 		}
// 	}
	
// 	// Wait for the first child process to finish
// 	if (waitpid(pid3, &status, 0) == -1)
// 	{
// 		perror("waitpid failed");
// 	}
	
// 	// Check if the child process terminated normally
// 	if (WIFEXITED(status))
// 	{
// 		fprintf(stderr, "status of cmd2 is %d\n", WEXITSTATUS(status));
// 	}
// 	else
// 	{
// 		fprintf(stderr, "cmd2 did not terminate normally\n");
// 	}

// 	pid_t pid4 = fork();
// 	if (pid4 == 0)
// 	{
// 		argv = make_cmd(shell, tree_node->right->right->start_token, tree_node->right->right->end_token)->args;
// 		fprintf(stderr, "cmd3[0] %s\n", argv[0]);
// 		int is_found = find_correct_path(pipex, argv);
// 		if (is_found)
// 		{
// 			fprintf (stderr, "execving cmd3 %s\n", argv[0]);
// 			execve(argv[0], argv, envp);
// 		}
// 		else
// 		{
// 			fprintf(stderr, "failed cmd3\n");
// 			exit(EXIT_FAILURE);
// 		}
// 	}
// 	wait(NULL);
// 	exit(EXIT_SUCCESS);
// }

// char *locate_env_path(t_env **envp)
// {
// 	t_env *current = *envp;  // Start at the head of the list

// 	// Traverse the linked list
// 	while (current)
// 	{
// 		// Compare the key portion with "PATH"
// 		if (ft_strncmp("PATH", current->keyvalue, 4) == 0)
// 			return (current->keyvalue);  // Return the actual string
		
// 		current = current->next;  // Move to the next node
// 	}
// 	return (NULL);  // If no "PATH" variable was found
// }

// void find_possible_paths(t_pipex *pipex, t_env **envp)
// {
// 	char *envp_path;

// 	envp_path = locate_env_path(envp);
// 	if (!envp_path)
// 		return;

// 	// Split the path and store it in pipex->possible_paths
// 	pipex->possible_paths = ft_split(envp_path + 5, ':');
	
// 	// Check if ft_split was successful
// 	if (!pipex->possible_paths)
// 	{
// 		// Handle error (e.g., log or return)
// 		return;
// 	}
// }


// void free_array(char **arr)
// {
// 	int i = 0;

// 	while (arr && arr[i])
// 	{
// 		free(arr[i]);
// 		i++;
// 	}
// 	free(arr);
// }

// // int create_pipe(t_pipex *pipex, t_shell *shell, t_tree *tree_node, t_env **envp)
// int create_pipe(t_pipex *pipex, t_shell *shell, t_tree *tree_node, char **envp)
// {
// 	if (pipe(pipex->fd) < 0)
// 		clean_nicely(pipex);

// 	pipex->pid1 = fork();
// 	if (pipex->pid1 == -1)
// 	{
// 		perror("First fork");
// 		clean_nicely(pipex);
// 		exit(EXIT_FAILURE);
// 	}
// 	else if (pipex->pid1 == 0)
// 		first_child(pipex, shell, tree_node, envp);

// 	pipex->pid2 = fork();
// 	if (pipex->pid2 == -1)
// 	{
// 		perror("Second fork");
// 		clean_nicely(pipex);
// 		exit(EXIT_FAILURE);
// 	}
// 	else if (pipex->pid2 == 0)
// 		second_child(pipex, shell, tree_node, envp);
// 	close_fds(pipex->fd[0], pipex->fd[1]);
// 	while (wait(NULL) != -1)
// 		;
// 	return (SUCCESS);
// }

// int handle_pipe_subtree(t_shell *shell, t_tree *tree_node)
// {
// 	t_pipex pipex;
// 	char **env_array;
	
// 	env_array = create_env_array(shell->env_list);
// 	ft_bzero(&pipex, sizeof(t_pipex));
// 	find_possible_paths(&pipex, &shell->env_list);
// 	create_pipe(&pipex, shell, tree_node, env_array);
// 	clean_nicely(&pipex);
// 	return (0);
// }

